# 요약

요약 도메인과 분석 방식에 대해 말글로 정리한다. 실제 소스의 어디에 구현되어있는지도 함께 달아둔다.


# 비트 벡터

## 요약 도메인

* [구현: RedProd](/lib/dom/bitVec/redProd.ml)

비트 벡터 요약 도메인은 3가지 도메인의 상호 보완하는 복합 도메인(Reduced Product Domain)으로 구성되어있다. 비트 나열 도메인(b), 부호 있는 구간 도메인(s), 부호 없는 구간 도메인(u).


### 비트 나열 도메인

* [구현: ABitSeq](/lib/dom/bitvec/aBitSeq.ml)

이론적으로는 각 비트 자리를 Bot, Top, One, Zero 4가지로 요약하고, 이것을 총 비트수만큼 나열한 것을 비트 벡터 요약값 하나로 취급한다.

그러나 실제 구현은 조금 다른데, Elem.t 타입의 값을 32개 혹은 64개씩 리스트로 가지고 다니면 32비트 문제 기준으로 값 하나당 대략 128바이트 씩을 차지하게 되며, 어떤 연산을 할 때마다 리스트의 포인터를 타고 다니며 순회를 해야하여 메모리와 시간의 낭비가 발생하기 때문이다. 실제 구현에서는 하나의 요약값이 64비트 정수 2개로 이루어져있다. 현재 이 구현의 제약으로 비트 길이가 64비트를 넘어서는 문제를 풀 수 없다. 표현 방법은 두 정수 m(mask), v(value)의 같은 자리에 위치한 각 비트 두개를 이용해 위의 4가지 요약값을 인코딩하는 것이다. 대략 아래와 같은 방식으로 인코딩된다.
```
elems[index] = match m[index], v[index] with
  | 0, 0 -> Zero
  | 0, 1 -> One
  | 1, 0 -> Bot
  | 1, 1 -> Top
```
이런 방식에는 소소한 장점이 몇 가지 있다.
* 메모리를 적게 쓴다 (64비트 기준으로 64개의 리스트 요소를 만들어 연결하는 대신 int64 객체 두개의 순서쌍으로 요약값 하나를 표현 가능)
* m 값이 0이면 이 요약값을 구체화하면 상수 하나에 대응된다는 사실을 바로 알 수 있으며 그 값을 v로 즉시 꺼낼 수도 있다.
* 반대로 c 상수 하나를 요약하고자 하면 m = 0, v = c 로 편리하게 요약값을 생성할 수 있다.
* and, or, xor 등 각 자리가 서로 무관한 비트 연산을 할 때, 32번 혹은 64번의 순회를 하는 대신 한 방에 비트 연산으로 값을 계산해낼 수 있다. (```join, meet, leq, forward_and/or/xor/not``` 등에 적용)

단, 처음에는 64비트 문제만을 가정하고 int64로만 모든 것을 만들었는데, 일반화된 비트수를 다루려다보니 약간의 추가 작업이 필요하게 되었다. Int64 라이브러리를 바로 사용하는 대신 MaskedInt64 라는 functor 를 만들어두고 비트 수에 맞게 상위 비트를 늘렸다 잘랐다 하는 작업을 추가해 일반화하였다. [구현: MaskedInt64(BitVecSize)](/lib/common/int64Util.ml)

```module MaskedInt64``` 은 ```module Type MaskedInt64Type``` 으로 가려져 사용되기 때문에, 64비트나 32비트와 고정된 비트수 문제에 대해 성능을 조금이나마 높이고자 한다면 MaskedInt64 펑터를 사용하는 대신 Int64, Int32 라이브러리를 직접 사용하도록 조금만 수정하면 된다.


### 부호 있는/없는 구간 도메인

* [구현(부호 있는): SignedIntv](/lib/dom/bitVec/signedIntv.ml)
* [구현(부호 없는): UnsignedIntv](/lib/dom/bitVec/unsignedIntv.ml)

부호 있는 도메인과 없는 도메인을 따로 구분하는 이유는 ``` bvudiv, bvsdiv, bvurem, bvsrem ``` 과 같이 값의 부호를 신경쓸 때와 신경쓰지 않을 때 서로 다른 결과를 내는 연산들을 잘 추적하기 용이하기 때문이다. 정확히 64비트 정수가 쓰일 때도 값을 잘 쫓아가기 위해 일반 ```int``` 타입이 아닌 ```int64``` 타입을 사용한다는 점, 그리고 비트 수에 제약이 있기 때문에 무한대 값을 따로 만들지 않아도 된다는 점을 제외하면 일반적으로 구간 도메인을 구현할 때와 크게 다르지 않은 방식으로 구현되어있다. 무한대에 해당하는 터진 값이 필요할 땐 그 표현에서 가장 큰 값을 사용하면 된다.


### 상호 보완 함수 (Reduction Operator)

[구현: RedProd.reduction*](/lib/dom/bitVec/redProd.ml#L113)

* unsigned intv (```reduction_step_u```)
  - from bits(```from_b```): b의 모든 top 비트를 0으로 채운걸 최솟값, 1로 채운걸 최댓값으로 취급하여 인터벌 구성
  - from signed(```from_s```): s 구간 양끝값의 부호가 같으면 그대로 사용, 다르면 사용 포기
    + 부호 있는 구간에서 부호가 다르다면 반드시 구체화된 값들에 -1(b111...1) 과 0(b000...0) 이 포함되는데, 이는 부호 없는 구간에서는 표현 가능한 최솟값과 최댓값이 되기 때문에 무조건 top이다.

* signed intv (```reduction_step_s```)
  - from bits(```from_b```): b의 모든 top 비트 중 msb(sign)는 1 & 나머진 0으로 채운걸 최솟값, msb는 0 & 나머진 1로 채운걸 최댓값으로 취급하여 인터벌 구성
  - from unsigned(```from_u```): u 구간 양끝값이 b0111...1 (signed max value) 과 1000...0 (signed min value) 에 걸쳐있으면 사용 포기, 걸쳐있지 않으면 그대로 사용
    + 위의 사유와 같다. 여기에 걸쳐있으면 부호 없는 구간에서는 1의 차이지만 부호 있는 구간에서는 top이 되기 때문.

* bits (```reduction_step_b```):
  s와 u 공히 구간 양끝값을 비트로 표현하여 common prefix를 살린다. common prefix 아래에 있는 비트들은 0과 1이 모두 올 수 있기 때문에 자연히 top이고, common prefix 는 구간 안의 어떤 값에서건 바뀌지 않기 때문.

* reduction: 위의 3가지 함수를 모두 먹이는 것의 고정점을 찾는다.


# 분석

* [구현: RedProd](/lib/dom/bitVec/redProd.ml)

정방향(forward) 분석과 역방향(backward) 분석을 순차적으로 수행한다. 원칙적으로 정방향과 역방향 분석도 고정점에 도달할 때까지 반복하는 것이 맞지만, 구현은 각 1회만 하도록 되어있다. 실제로 고정점 반복을 하도록 구현해서 실험해봤지만 실제로 2회 이상 반복이 이뤄지는 경우는 없었고 구현만 복잡해져서 원상복구 하였다.

각 연산자 별 정방향/역방향 요약 연산은 별도의 모듈로 빼지 않고 복합 도메인 모듈 안에 포함시켰다. 복합 도메인의 내부 구조에 의존성이 커서 분리해서 얻을 수 있는 이점이 별로 없어보였다.

forward 요약 연산은 피연산자의 요악값들을 받아 결과값의 요약값을 계산해낸다.
backward 요약 연산은 피연산자와 결과값의 요약값들을 모두 받아 피연산자 두 개의 깎아낸 요약값을 계산해낸다.

예를 들어 bvadd x y = z 에서,
* forward_add 는 hat(x) 와 hat(y) 를 받아 hat(z)를 계산해낸다.
* backward_add 는 hat(x), hat(y), hat(z)를 받아 hat(x)', hat(y)' 을 계산해낸다. 이때 forward와 달리 hat(z)가 입력으로 들어올 수 있는 이유는 I/O pair의 output 값을 요약한 값을 역방향으로 전파시킬 수 있기 때문이다.

## 연산들

### (forward/backward) bvnot

비트 뒤집기. 상식적으로 정의하고 구현하면 된다. 특이하다 할만한 점은 구간 도메인에서도 마치 일반적으로 negation 연산을 분석할 때처럼 양끝값을 not 한 후 순서를 바꾸면 된다는 점이다.

### (forward/backward) bvneg

산술적 마이너스. bvnot에 비해 조금 까다로운 면이 있다. 예를 들어 0은 bvneg 연산을 거쳐도 여전히 0인데, 만약 부호 없는 구간 도메인에서 ```[0, 3]``` 을 뒤집는다 하여 ```[-3, 0]``` 으로 계산하려 하면 잘못된 결과를 얻게 될 것이다. 구체화 -> bvneg -> 재요약을 해보면
0 -> 0
1 -> -1(b111..11) = unsigned_max_int
2 -> -2(b111..10) = unsigned_max_int - 1
3 -> -3(b111..01) = unsigned_max_int - 2
이므로 안전한 분석을 하려면 bvneg([0, 3]) 의 요약은 top이 나와야한다. 그렇다고 0이 포함된 값에 대한 bvneg를 무조건 top으로 보내는 것도 안 된다. bvneg([0, 0]) 의 요약은 [0, 0] 이 맞기 때문에.

한편, signed_min_int 에 해당하는 b100...0 에 bvneg 연산을 수행하면 그대로 b100...0 이 나오게 된다. 즉 8비트 세계에서 -128 에 마이너스를 먹이면 다시 -128 이 나오는 것이다. 평범한 정수의 세계에서는 이것이 오류로 보일 수 있지만 우리가 다루고 있는 비트 벡터의 세계에서는 실제 연산이 이렇게 이뤄지므로 우리도 그에 맞춰 분석을 해야한다.

이렇게 forward_neg 및 backward_neg 는 특수한 경계에 걸쳐있는 값들에 대해 예외처리를 하고 나머지 경우에 대해 일반적인 뒤집기를 하도록 구현했다.

### (forward) bvadd, bvsub, bvmul

구간 도메인에서는 사칙연산들을 상식적인 선에서 평범하게 구현했다. 단, 오버플로 발생 가능성을 항상 체크해야한다. 오버플로가 발생한 도메인에서는 결과가 top 값이 되어야한다.

비트 나열 도메인에서는 bvadd에선 비트별로 carry를 올리며 덧셈하는 과정을 모방하여 구현해서 최대한 비트 내용들을 보존할 수 있도록 했다. bvsub는 neg와 add의 조합으로 간접 구현했다. mul은 특별히 postfix 정보를 활용했는데, 예를 들어 10진수 세계에서 23400 * 6431340 을 계산할 때 맨 뒤에 있는 0의 갯수는 그대로 더해져 1000의 배수가 나온다는 사실을 알 수 있는 것처럼, 비트에서도 맨 뒤에 붙은 Zero 비트의 갯수가 보존되는 것을 반영해 요약 연산을 만들었다.

### (forward) bvsrem

우선 bvsrem의 정의에 따르면 i1의 부호는 결과값에 영향을 미쳐서 i1이 음수이면 결과도 음수가 된다. i2의 부호는 무시되어 무조건 절댓값이 사용된다. 결과의 절댓값은 두 피연산자의 절댓값을 이용한 나머지 연산 결과이다.
```
(bvsrem s t) abbreviates
      (let ((?msb_s ((_ extract |m-1| |m-1|) s))
            (?msb_t ((_ extract |m-1| |m-1|) t)))
        (ite (and (= ?msb_s #b0) (= ?msb_t #b0))
             (bvurem s t)
        (ite (and (= ?msb_s #b1) (= ?msb_t #b0))
             (bvneg (bvurem (bvneg s) t))
        (ite (and (= ?msb_s #b0) (= ?msb_t #b1))
             (bvurem s (bvneg t)))
             (bvneg (bvurem (bvneg s) (bvneg t))))))
```

이 정의를 잘 따라가기 위해 각 구간값을 부호에 따라 양의 구간과 음의 구간으로 쪼갠 다음[(sign_split)](/lib/dom/bitVec/signedIntv.ml#L63) 4가지 각 조합에 따라 따로 연산을 한다.
예를 들어 [-5, 8] 이라는 구간 요약값은 음의 구간 [-5, -1]과 양의 구간 [0, 8]로 쪼갤 수 있다. 이 때 음의 구간이나 양의 구간이 없는 구간, 예를 들어 [4, 8]을 쪼갠다면 음의 구간으로는 bottom이, 양의 구간으로는 원래 요약값인 [4, 8]이 나온다.

i1의 요약값의 양수 부분과 음수 부분을 각기 p1, n1으로, i2도 마찬가지로 p2와 n2로 표기하기로 한다. 나머지 연산 결과의 절댓값은 각 피연산자의 절댓값을 이용해 계산되므로 우선 n1과 n2은 기존의 forward_neg 연산을 활용해 절댓값의 요약값을 계산해낸다. 이를 각각 p_n1, p_n2라고 할 때 나머지 요약 연산은 p1 % p2, p1 % p_n2, - (p_n1 % p2), -(p_n1 % p_n2) 이렇게 4가지 경우로 나누어 계산한 후 이 모든 경우를 join 하면 된다. (concretize 하여 모든 조합에 대해 구체적 연산을 취한 후 다시 abstract 하는 방법을 생각해보면 된다)

여기서 한가지 예외 케이스로 forward_neg 연산을 통과하고 나서도 범위 안에 음의 값이 단 하나 남아있을 수 있다는 점을 고려해야한다. 바로 `b'1000...0`, 즉 signed min int 이다. 예를 들어 8비트 도메인에서는 -128이 문제가 된다. 이 값은 neg 연산을 취해도 여전히 `b'1000...0` 그대로의 값을 유지하기 때문에 아래 이어지는 `rem_aux` 로직에서 따로 취급해야한다.

이제 문제는 양쪽 모두 절댓값을 취하여 양수 범위가 된 상태에서 나머지 요약 연산을 정의하는 것으로 좁혀진다. 이것은 내부에 추가 정의된 [`rem_aux`](/lib/dom/bitVec/signedIntv.ml#L198) 함수로 구현되어있다.
`rem_aux (SIntv(l1, r1)) (SIntv(l2, r2))` 의 결과를 계산해보자.

제일 먼저, 만약 `r2 = 0` 이라면 `l2`도 반드시 0이 되고 (아래의 forward_neg에 의한 예외 signed_min_int 케이스만 제외하면 반드시 `0 <= l2 <= r2` 이므로) 0으로 나눈 나머지 계산은 undefined semantics 이므로 결과는 bot이다.

우선 위의 forward_neg 정의에 의한 예외 케이스, signed_min_int가 구간 안에 존재하는지 확인한다.
signed_min_int 가 forward_neg 연산의 결과값 구간에 남아있다면, 즉 lower bound가 signed_min_int라면 항상 이 결과값은 top이거나 아니면 [signed_min_int, signed_min_int] 인 두 가지 경우 뿐이다.

어떤 `forward_neg [l, r]` 의 결과 `[l', r']` 을 생각해보자.
`forward_neg의` 정의에 의해, `l'` 값이 `signed_min_int` 이려면 이 값은 `neg r` 에서 유래했거나 `[l', r']`이 top 이라서 사용된 것이다.
`neg r = signed_min_int` 이려면 `r = signed_min_int` 여야만 한다.
정상적으로 정의된 signed interval 값에서 upper bound가 signed min int일 방법은 `[signed_min_int, signed_min_int]`인 경우 뿐이다. 사용 가능한 값 중 가장 작은 값이 upperbound로 사용되었기 때문에.

top인 경우는 아래 설명할 일반적인 나머지 연산 로직에서 자연히 정의되므로 따로 생각할 필요는 없다.
그렇다면 `[signed_min_int, signed_min_int]` 일 때만 생각하면 되는데 이 경우를 확인하는 방법은 바로 위에 설명한 바에 의해 upper bound가 `signed_min_int`인지 확인해보는 것이다.
이렇게 확인하여 l1=r1=signed_min_int인 경우, l2=r2=signed_min_int인 경우, 둘 다 signed_min_int인 경우 세 가지를 별도의 예외로 취급한다.
둘 다 `signed_min_int` 라면 같은 값끼리의 나머지 연산 결과는 0이므로 `[0,0]`이다.
l1=r1 만 `signed_min_int` 라면 이를 bvurem 연산의 첫 피연산자로 사용했을 때 그 결과값의 범위는 아래와 같이 좁힐 수 있다.
예를 들어 `b'10000000 % b'01111111 = 1`, `b'10000000 % b'01111110 = 2`, ..., `b'10000000 % b'01000001 = 63`, `b'10000000 % b'01000000 = 0`, 즉 `signed_min_int mod (signed_min_int / 2 + 1) = signed_min_int / 2 - 1` 일 때 `signed_min_int / 2 - 1`이 결과로 나올 수 있는 가장 큰 값이다. 따라서 l2, r2가 어떤 값이라 해도 결과는 최대 `[0, signed_min_int / 2 - 1]` 의 범위 안에 있어야한다.
여기에 더해 나머지 연산은 두번째 피연산자의 값보다 크거나 같을 수 없으므로, 이 연산의 결과는 `[0, signed_min_int / 2 - 1] meet [0, r2 - 1]` 이 된다.

l2=r2 만 `signed_min_int` 라면 결과값은 `[l1, r1]` 값과 같다. 나누기 연산 결과의 몫이 무조건 0이므로. 따라서 이 값을 그대로 결과로 사용한다.

둘 중 어떤 값에도 signed_min_int 가 범위에 포함되어있지 않다면 이 요약 연산의 결과는 정확히 계산하기 어렵다.
그러므로 가장 간단한 방법을 사용하기로 한다. 우선 어떤 경우에도 결과값은 0에서 두 번째 피연산자보다 1 작은 값 사이에 존재해야한다.
또한 어떤 경우에도 나머지 연산의 결과값은 첫번째 피연산자의 값보다 클 수 없다.
이 두 사실을 조합하면 결과값의 범위는 `[0, min(r1, r2 - 1)]` 이다.

이렇게 정의된 절댓값에 대한 bvurem 의미를 활용하여 각 부호 조합별로 4가지 케이스를 계산한 후 전체를 다시 join 하면 bvsrem에 대한 forward 연산을 수행할 수 있다.

### (forward) bvurem

위의 bvsrem 의 간단한 버전으로 생각할 수 있다. l2 = r2 = 0 이면 undefined semantics에 의해 bot. 그 외의 경우 `[0, min(r1, r2 - 1)]` 이다.

### (forward) bvsdiv

bvsdiv의 정의는 bvsrem과 유사하게 부호에 따라 나누어 정의되어있다. 따라서 비슷한 방식으로 4가지 부호 조합을 나누어 분석한다.

```
(bvsdiv s t) abbreviates
      (let ((?msb_s ((_ extract |m-1| |m-1|) s))
            (?msb_t ((_ extract |m-1| |m-1|) t)))
        (ite (and (= ?msb_s #b0) (= ?msb_t #b0))
             (bvudiv s t)
        (ite (and (= ?msb_s #b1) (= ?msb_t #b0))
             (bvneg (bvudiv (bvneg s) t))
        (ite (and (= ?msb_s #b0) (= ?msb_t #b1))
             (bvneg (bvudiv s (bvneg t)))
             (bvudiv (bvneg s) (bvneg t))))))
```

`signed_min_int` 값이 등장할 때 예외 처리를 하는 것도 거의 동일하다.
단, signed_min_int / signed_min_int = 1이다.
signed_min_int / some_value 는 일반적으로 계산하면 된다. (작은 값으로 나눈 것을 upperbound, 큰 값으로 나눈 것을 lowerbound)
some_value / signed_min_int 는 무조건 0이다.

그 외 일반적인 나눗셈에 대해서는 큰 값을 작은 값으로 나눈 것을 upperbound, 작은 값을 큰 값으로 나눈 것을 lowerbound로 취급한다.
단, bvsrem과 다른 점은 top 값에 대해서 따로 처리해야한다는 점이다. bvsrem 에서는 lowerbound 쪽엔 아예 관심이 없기 때문에 따로 처리하지 않아도 문제가 되지 않았다.
bvsdiv 내의 `div_aux`에 넘어온 첫번째 피연산자가 top이라면, `b'1000...0`에서 `b'0111...1` 까지 모든 값이 가능하다는 뜻이다.
이때 두번째 피연산자 `[l2, r2]`의 범위 안에 1이 담겨있을 수 있다면 이 경우에 첫번째 피연산자 값이 그대로 전달되므로 결과는 top이다.
1을 포함하지 않는 범위라면 두번째 피연산자는 top이 아니다(top은 1을 당연히 포함하므로). 따라서 정상적으로 signed_min_int 값을 l2로 나눈 것이 최댓값이고 0이 최솟값이 된다.

### (forward) bvudiv

bvurem과 bvsrem의 관계와 마찬가지로 bvsdiv의 간단한 버전으로 생각할 수 있다.

### (forward) bvand, bvor, bvxor

비트 나열 도메인에서 상식적으로 구현했다.

### (forward) bvlshr, bvashr, bvshl

피연산자 1은 비트 나열 도메인, 피연산자 2는 구간 도메인을 활용하고 피연산자 2의 구간 값을 실제 구체화하여 비트 나열 도메인 값을 쉬프트 시킨 것들을 모두 join 하는 과정을 효율적으로 모방했다. 최대 64비트 문제르 푼다고 가정했을 때 피연산자2를 최대한 구체화 해서 쉬프트를 수행해봤자 63회까지만 하면 되기 때문에 성능에 크게 문제가 없을 것으로 보았다.

### (backward) bvadd, bvsub

구간 도메인에서 상식적으로 구현했다.

### (backward) bvand, bvor, bvxor

비트 나열 도메인에서 각 비트 자리 단위로 상식적으로 구현했다.
x and y = 1 이면 x = 1, y = 1
x and y = 0 && x = 1 이면 y = 0
x or y = 0 이면 x = 0, y = 0
x or y = 1 && x = 0 이면 y = 1
x xor y = 0 && x = 0 이면 y = 0
x xor y = 0 && x = 1 이면 y = 1
...

### (backward) bvlshr, bvashr, bvshl

```*sh* b i = post```

우선 post의 비트 도메인으로부터 shift 거리의 조건을 계산한다.

lshr을 수행한 결과에서는, 적어도 shift 한 거리만큼 prefix가 연속으로 0으로 채워져있어야한다. 그리고 처음으로 0이 아닌 비트가 나온 위치에 따라 shift 한 거리의 최댓값이 정해진다.
ashr을 수행한 결과에서는, 적어도 shift 한 거리만큼 msb와 동일한 비트가 연속으로 채워져있어야한다. 마찬가지로 처음으로 msb와 다른 비트가 나온 위치에 따라 shift 한 거리의 최댓값이 정해진다.
shl을 수행한 결과에서는, 적어도 shift 한 거리만큼 suffix가 연속으로 0으로 채워져있어야한다. 처음으로 0이 아닌 비트가 나온 위치에 따라 shift 한 거리의 최댓값이 정해진다.
이때 카운트 도중 Top 비트를 만났다면 최대한 안전하게 계산해야하므로 종료 조건을 만족하지 않은 것으로 본다.
단, ashr의 msb가 Top 비트일 경우에는 처음으로 0과 1을 '모두' 만나는 순간을 종료 조건으로 계산한다. 즉, TT0TTT1... 에서는 최대 0000001 일 때 5칸 ashr을 수행한 결과일 수 있으므로 거리 최댓값은 5이다.

이렇게 구한 shift 가능 거리는 i의 범위에 meet 된다.

이제 이 shift 가능 거리 범위를 전부 따져보며 forward shift와 비슷한 방식으로 post를 역방향으로 shift 시켜보고 그 값들을 각 비트 자리마다 join 하면 b의 비트도메인 값을 구할 수 있다.

### (backward) bvmul

일반적인 요약 해석에서는 별로 등장할 일이 없는 꽤 복잡한 방법을 사용했다.

우선 주요 착안점은, 우리가 양방향 합성을 진행하면서 '만들다 만' 프로그램을 분석하기 때문에 어떤 연산의 한 피연산자에는 부품이 꽂혀있어서 완전히 계산된 상수 값이 나올 가능성이 상당하다는 것이다. 즉, 요약 해석이지만 한쪽 값이 구체화 했을때 원소가 단 하나인 경우가 적지 않다. 혹은 원소가 손에 꼽을만큼 적어서 일일이 헤아릴 수 있는 집합이 나올 수도 있다. 예를 들어 비트를 딱 두 자리만 모르는 비트 나열 도메인을 생각해보면 이 요약값을 구체화하면 4가지 경우밖에 나오지 않기 때문에 이것들을 전부 개별 상수 취급하면 아주 정확한 분석을 할 수 있게 된다. 요약 도메인 위에서 계산을 하는 대신 상수에 대해 직접 계산을 할 수 있기 때문에.

다음과 같은 상황을 생각해보자. 우리는 길이 8인 비트 벡터 도메인 문제를 풀고있고 CEGIS 과정에서 I/O 페어로 f(6) = 24 를 보유하고있다. 이때 곱셈 연산에 인자 x를 꽂아넣은 중간 프로그램 ```bvmul [hole1] x``` 을 분석중이라면,

```bvmul [hole1] 6 = 24```

위와 같은 상황에서 우리는 ```[hole1]``` 을 미지수로 둔 방정식을 풀면 그 자리에 올 수 있는 부품들을 좁은 범위로 추려낼 수 있게 된다.

우리가 평범한 정수의 구간 분석을 하고있다면 이럴때 hole1 의 요약값을 4로 얼른 계산하고 싶을테지만, 사실은 그렇지 않다. 사실 위의 방정식에는 (mod 2^8)가 생략되어있기 때문이다.

```[hole1] * 6 = 24 (mod 2^8)```

현재 역방향 곱셈 분석은 이런 상황에서 다음과 같이 미지수 ```[hole1]```의 값을 알아낸다.
우선, 6과 24는 모두 짝수인데 6 자리에 홀수가 오도록 문제를 다듬는다. 알고리즘으로는 6의 비트 표현 상 postfix zero가 몇개인지 확인하고 그만큼 right shift를 시키면서 같은 갯수만큼 우변의 24도 right shift 시킨다. 만약 이때 24의 postfix zero 갯수가 6에 비해 모자라다면 이 방정식에는 해가 없는 것이므로 요약값 계산 결과는 bottom이다.

* 약분에 실패하면 bottom 인 이유

곱셈 결과값의 postfix zero 갯수가 피연산자 중 하나의 postfiz zero 갯수보다 모자라면 결과가 bottom인 이유는 다음과 같다.
예를 들어 ```a * b = c (mod 2^N)``` 이 주어졌을 때, a,b,c가 모두 0이 아니라면 다음과 같이 고쳐써볼 수 있다.
(a 또는 b가 0이라면 c는 반드시 0이어야하므로 간단히 따로 처리, a와 b가 0이 아닌데 c가 0인 경우는 또 따로 처리)

```a = 2^p * S (S는 홀수, 0 <= p < N)```
```b = 2^q * T (T는 홀수, 0 <= q < N)```
```c = 2^r * U (U는 홀수, 0 <= r < N)```

이 때 아래와 같은 식이 항상 성립해야 한다면 위의 'postfix zero 갯수'에 대한 주장('p > r이면 bottom이다')도 성립하게 된다.
```p + q = r```

처음 제시한 a,b,c에 관한 식을 p,q,r을 사용하며 mod 없이 자연수로 일반화하면 아래와 같이 표현할 수 있다.

```(2^p * S + X * 2^N) * (2^q * T + Y * 2^N) = 2^r * U + Z * 2^N```
```2^p * S * 2^q * T + 2^p * S * Y * 2^N + 2^q * T * X * 2^N + X * Y * 2^2N = 2^r * U + Z * 2^N ```

여기서 양변에 다시 mod 2^N 을 취하면

```2^(p + q) * S * T = 2^r * U (mod 2^N) (S, T, U는 홀수)```

```S, T, U```는 홀수여서 2의 거듭제곱 부분에는 영향을 절대 미치지 못하므로 ```p + q < N```일 때 ```p + q = r``` 이다.
만약 p + q >= N 이라면 우변의 c는 0이 되어야하므로 c가 0이 아니라는 가정을 위반. 따라서 a, b, c가 0이 아니라면 ```p + q = r``` 이다.

c가 0인데 a, b가 모두 0이 아닌 경우는 ```p + q >= N``` 일때 뿐이다. 이땐 0의 갯수가 우변은 N개, 좌변의 a와 b는 0의 갯수가 N개보다 작다고 가정했으므로 '피연산자 postfix zero의 갯수보다 결과값의 postfix zero 갯수(N개)가 모자란 상황이 아니므로 고려할 필요 없음.

```[hole1] * 3 = 12 (mod 2^7)```

여기서 확장된 유클리드 알고리즘을 사용하면 mod 2^7 영역에서 3의 유일한 역수가 43이라는 사실을 알아낼 수 있다. 이 역수를 양변에 곱한다. 3과 43은 mod 2^7 에서 역수 관계이므로 곱하면 1로 사라진다.
> 참고자료:
> * (블로그 1)[https://www.crocus.co.kr/m/1232]
> * (블로그 2)[https://baeharam.github.io/posts/algorithm/extended-euclidean/]
> * (블로그 3)[https://rebro.kr/m/97]

```
[hole1] * 3 * 43 = 12 * 43 (mod 2^7)
[hole1] = 516 (mod 2^7) = 4 (mod 2^7)
```
이제 방정식은 다 풀었다. ```[hole1]```은 mod 128 에서 4와 합동이므로 ```[hole1] = 128 * K + 4``` 이고 이를 다시 mod 256 의 세계로 복귀시키면

```
[hole1] = 4   (mod 2^8) (when K = 0)
          132 (mod 2^8) (when K = 1)
```
이렇게 2개의 정확한 값을 얻을 수 있다. 숫자로 표현할 땐 여기서 끝이지만 우리에겐 비트 나열 도메인이 있다. 앞서 6을 홀수 3으로 만들기 위해 2를 한 개 뺐기 때문에 K에 0과 1이라는 2가지 값이 올 수 있었다. 만약 처음에 2를 2개 뺐으면 K에는 0에서 3까지 4가지 값이 올 수 있었을 것이다(64 * K의 형태로). 이것을 비트 나열 도메인 위에서 잘 생각해보면, 최초에 제거한 postfix zero 와 같은 갯수만큼 높은 자리 비트가 뭐든 올 수 있는 Top 값인 상황이라는 사실을 알 수 있다. 즉, ```[hole1] = bT0000010``` 이다.

bvmul 에서 피연산자 한 개가 임의의 상수이고 결과값 또한 상수일 때, 위의 예제를 일반화시킨 알고리즘을 통해 방정식을 풀 수 있고 아직 빈칸인 피연산자 자리에 대해 비트 나열 도메인으로 잘 표현된 요약값을 만들어낼 수 있다. 곱셈 연산은 산술 연산임에도, 곱셈의 역방향 요약 연산에서는 구간 도메인에 비해 비트 나열 도메인이 더 표현력이 좋다. 비트 나열 도메인으로 표현된 ```[hole1]```의 요약값을 구체화하면 정말 그 자리에 올 수 있는 모든 값의 집합이 정확히 나온다. 즉, 이보다 더 잘 요약할 수 없는 가장 완벽한 요약값이 비트 나열 도메인에서 표현된다.

* 위와 같이 약분 후 복원하는 과정을 거쳐도 되는 이유

위의 상황을 일반화하면 아래와 같다.

``` X * (2^p * Y) = 2^q * Z (mod 2^N) (p < q < N, X, Y, Z < 2^N) ```

위의 식에서 홀수 Y의 역수를 찾고 싶은 것이다. 위의 식에서 mod를 제거하면

``` X * (2^p * Y) = 2^q * Z + S * 2^N ```
양변을 2^p로 나누면

``` X * Y = 2^(q-p) * Z + S ^ (2^(N-p)) ```

이 식을 다시 mod 2^(N-p) 로 표현하면

``` X * Y = 2^(q-p) * Z (mod 2^(N-p))```

여기서 ```Z * 2^(q-p)``` 는 원래의 ```2^q * Z```를 p만큼 logical shift right 한 것이다.

어떻게든(=확장 유클리드 알고리즘을 활용해) mod 2^(N-p) 세계에서 홀수 Y의 역수 Y'을 구했을 때 이를 양변에 곱하면

``` X * Y * Y' = 2^(q-p) * Z * Y' (mod 2^(N-p)) ```
``` X = 2^(q-p) * Z * Y' (mod 2^(N-p)) ```

이 식을 다시 mod 없이 표현하면

``` X = 2^(q-p) * Z * Y' + T * 2^(N-p) ```

이 식을 다시 mod 2^N 으로 표현하면

``` X = (2^(q-p) * Z) * Y' + T * 2^(N-p) (mod 2^N)```

여기서 ```2^(q-p) * Z``` 는 N비트 벡터를 logical shift right 한 것이므로 여전히 N비트 세계에서 유효한 수. Y'는 N-p비트 벡터 세계에서도 유효했던 숫자이므로 역시 N비트 벡터 세계에서두 유효한 수. 그리고 ```+ T * 2^(N-p)``` 부분은 N비트 벡터 세계에서 해석하면 T는 임의의 상수이므로 N비트 벡터 세계에서 상위 p개 비트에 아무 숫자나 넣어도 되게 만들어주는 효과가 있다.

만약 곱셈의 어느 한 쪽의 요약값이 상수로 떨어지지 않는다면, forward_mul에서와 마찬가지로 suffix zero의 갯수에 대한 정보만 활용한다.

### (backward) bvudiv

두 피연산자 중 어느 쪽에 먼저 부품이 공급되는가에 따라 더 정보가 확보되는 순서가 달라지므로, post와 d1의 정보로 d2의 정보를 유추하는 방법과 post와 d2의 정보로 d1의 정보를 유추하는 방법을 모두 제시한다.

* d2와 post의 정보를 활용하는 방법

`d2 = [0, 0]` 이라면 undefined semantics로 인해 결과는 bot, bot이다.
그 외의 경우에, `bvudiv d1 d2 = post` 일때 `d1 = d2 * post + remainder (remainder in [0, d2 - 1])` 이라는 사실을 알 수 있다.
단, d2 * post 에서는 overflow가 발생하지 않아야한다. 이러한 사실을 활용할 수 있다.
마침 우리는 forward_mul 요약 연산에서 오버플로우 발생을 감지하고 결과를 top으로 만드는 로직을 가지고있다.
만약 post와 d2의 구체화 된 결과가 정확히 상수 한 개라면, 즉 값을 정확히 알고있다면 이 두 요약값을 forward_mul 한 결과에서 overflow가 발생하지 않았다면 결과값도 하나의 상수, overflow가 발생했다면 top이 될 것이다.
따라서 이렇게 두 값이 단일 상수일 때 forward_mul post d2 의 결과가 top이라면 불가능한 상황이 발생한 것으로 보며 결과는 bot, bot 이다.
그 외의 경우 위의 식에 의해 `forward_mul d2 post` 에 `[0, upperboud of d2 - 1]` 을 더한 값이 d1의 요약값이 된다.

* d1과 post의 정보를 활용하는 방법

```
d1 = d2 * post + r2 (r2 in [0, d2 - 1])
d1 / post = d2 + r2 / post
let k = r2 / post
let x = d1 / post
x = d2 + k
d1 = x * post + rp (rp in [0, post - 1])
   = (d2 + k) * post + rp
   = d2 * post + k * post + rp
=> r2 = post * k + rp
```

우리는 d2의 범위를 찾고 싶고 우리가 실제로 계산해낼 수 있는 값은 x와 rp이다. r2와 그로 인해 정해지는 k의 값에 따라 d2의 값이 달라질 수 있다.

```
case 1: if x <= post

d2 <= x (because x = d2 + non_negative)
r2 < d2 (because r2 in [0, d2 - 1])

=> r2 < d2 <= x <= post
=> r2 < post
=> r2 / post = 0
=> x = d2
```
이 경우 우리가 구한 x가 바로 d2가 된다.

```
case 2: if x > post

d2 = x - k
d1 = d2 * post + k * post + rp
k * post + rp = r2 < d2 (because k * post + rp = r2)
k * post + rp = r2 < x - k
k * (post + 1) + rp < x
```
위의 부등식에서 우리는 post와 rp와 x를 모두 알고있다. 따라서 k의 범위를 구할 수 있다.

예를 들어, 1301 / d2 = 13 에서 빈 칸의 값을 알고싶다고 가정하자.
실제로 수작업으로 나열하며 계산해보면 d2에는 93에서 100까지의 값이 올 수 있다는 사실을 알 수 있다.
```
1301 / 92 = 14 (x)

1301 / 93 = 13, 1301 % 93 = 92
1301 / 94 = 13, 1301 % 94 = 79
...
1301 / 99 = 13, 1301 % 99 = 14
1301 / 100 = 13, 1301 % 100 = 1

1301 / 101 = 12 (x)
```

이 범위를 직접 나열 없이 앞서 세운 식을 따라 아래와 같이 계산해낼 수 있다.
```
1301 / 13 = 100 (:x)
1301 % 13 = 1   (:rp)

it's case 2: 100 > 13

d2 = 100 - k
1301 = d2 * 13 + k * 13 + 1
k * 13 + 1 < d2
k * 13 + 1 < 100 - k
14 * k + 1 < 100
14 * k < 99
k < 7.07...
k in [0, 7]
100 - k in [93, 100]
```

이와 같이, `d1 / post = x`를 계산해보고 x가 post 이하이면 그 값이 d2이다. x가 post보다 크다면 나머지인 rp도 계산해보고 `k < (x - rp) / (post + 1)` 를 계산하고 나면 이를 통해 d2의 범위를 ```[x - k, x]```로 계산할 수 있다.

이제 이를 d1과 post가 특정 상수가 아닌 구간값인 경우로 확장해보자. d1 in [l1, r1] 이고 post in [lp, rp]이다.
post가 고정되어있을 때, d1이 증가하면 그에 따라 d2는 단조증가한다.
반대로 d1이 고정되어있을 때, post가 감소하면 그에 따라 d2는 단조증가한다.
이런 점을 활용하면, l1과 rp를 사용하면 d2의 최솟값 범위, 그리고 r1과 lp를 사용하면 d2의 최댓값 범위를 알 수 있으므로 이 두 범위를 join하면 d1의 최종 범위를 알 수 있다.

### (backward) bvsdiv

forward bvsdiv 에서 보았듯이, 연산의 정의에 따라 각 부호 조합별로 경우의 수 계산이 필요하다.

bvsdiv d1 d2 = post 에서 아래와 같이 쪼갠다.

d1을 양수임을 가정한 pos_d1, 음수임을 가정한 neg_d1 으로 쪼갠다.
d2도 마찬가지로 pos_d2, neg_d2 로 쪼갠다.
post도 pos_post, neg_post 로 쪼갠다.

이후 각 조합별로 backward bvudiv 분석을 수행한다.

bvudiv pos_d1 pos_d2 = pos_post
bvudiv (forward_neg neg_d1) (forward_neg neg_d2) = pos_post

bvudiv (forward_neg neg_d1) pos_d2 = neg_post
bvudiv pos_d1 (forward_neg neg_d2) = neg_post

각각에서 forward_neg 를 먹여 절댓값으로 바꿨던 경우에는 backward 결과값도 다시 forward_neg 하여 부호를 되돌린다.
이후 각 조합별 결과 4가지를 join한다.

단, 여기서 부호 쪼개기는 단순히 signed 도메인에서만 이루어지는 것이 아니라 모든 세부 도메인에서 수행된다.
```
sign_split_sintv [l,u]  =
  neg_part = [l, -1] or bot when l >= 0
  pos_port = [0, u] or bot when u < 0
sign_split_uintv [l,u] =
  neg_part = [signed_min_int, u] or bot when u < signed_min_int
  pos_part = [l, signed_max_int] or bot when l >= signed_min_int
sign_split_bitseq b'mxxxxxxx... =
  neg_part = b'1xxxxxxx... or bot when m is 0 or bot
  pos_part = b'0xxxxxxx... or bot when m is 1 or bot
```

따라서, 아이러니 하게도, 부호를 고려하는 연산이지만 unsigned domain도 유용하게 사용되게 된다. 왜냐하면 signed domain 에서는 signed_min_int 가 포함되었을 떄 neg_part의 절댓값 표현 구간에 signed_min_int가 다시 포함되어 정보가 뭉개지고 말지만 unsigned domain에서는 signed_min_int 가 포함된 neg_part에 대해서 forward_neg 를 수행하고 나면 그 결과가 기존 구간의 정확도를 정확히 보존해주기 떄문이다.
이러한 점은 아래에 같은 방식으로 bvurem을 활용해 정의하는 bvsrem 분석에서도 동일하게 관찰된다.

### (backward) bvurem

```
bvurem d1 d2 = post
```

우선 운 좋게 d1과 post의 요약값을 구체화한 결과가 각각 singleton set인 경우, d2의 조건을 정교하게 추출하는 것을 시도할 수 있다.
결과로는 '활용하지 않음'과 '활용하며 d2는 bot이거나 정확한 값'이다.

* d1 = post 일때:
  post < d2 라는 사실만 알 수 있는데, 나중에 요약값을 이용할 때도 자연히 활용되므로 이 단계에서는 활용하지 않는다.

* d1 = 0일 때
  - 앞서 d1 = post를 걸렀으므로 post != 0: 식이 성립 불가능하므로 bot 이다.

* post의 msb가 1이면, 즉 signed_min_int보다 크거나 같다면: d1 과 post가 반드시 같아야한다.

이유는 다음과 같다. d1 % d2 = post 에서 post >= signed_min_int 이면, d1 > signed_min_int 이다.
그런데 비트 길이가 한정되어있기 때문에 signed_min_int의 두배 이상 큰 값은 등장할 수 없다.
따라서 d1 / d2 는 d1 >= d2 일때 1, d1 < d2 일때 0이다. 그럼 post와의 관계가 좀 더 명확해져서, 대소비교 부등호 대신 등호를 사용할 수 있게 된다.
d1 >= d2 일때 d1 - d2 = post, d1 < d2 일때 d1 = post 이다. (단, 이 관계에서 연산 도중 overflow는 발생해서는 안 된다)
d1 >= d2 를 가정하면 rem 연산 특성상 d2 > post 여야 하는데 post >= signed_min_int 를 가정했으므로 d1 = d2 + post 에서 signed_min_int 이상인 두 값을 더하여 overflow가 발생한다. 따라서 d1 >= d2일 수 없다.
즉 d1 = post 이고 d2 > post 이다. 이 조건을 이용해, d1과 post가 서로 다르다면 d2를 bot으로 결론내릴 수 있다.

* d1 < post 이면 불가능한 경우이므로 bot.

* 그 외의 경우 (d1 > post && d1 != 0 && post < b'1000...0):

```
d1 = d2 * q + post
d1 - post = d2 * q
```

여기서 d2는 d1 - post 의 약수여야함을 알 수 있다.
  - 만약 d1 - post 가 솟수라면 q = 1, d2 = d1 - post 여야 한다.
  - 솟수가 아니라면 d1 - post 에는 1개 이상의 진약수가 존재할텐데, 그 중 가장 큰 진약수 X에 대해:
    + X <= post 라면 rem 연산 특성상 post < d2 여야하므로 X < d2 이다. 그런데 d2가 가장 큰 진약수보다 크다면 q = 1일 수밖에 없다. 따라서 d2 = d1 - post 이다.
    + 단, d1 = post * 2 인 경우에는 위의 식 d1 - post = d2 * q 에서 q = 1, d2 = post 가 되는데 d2 > post 라는 조건과 상충되어 모순이 발생하므로 d1 = post * 2 일때는 d2 = bot 이다.

이제 솟수 판정 혹은 X를 구하는 것이 문제가 되는데, 정확한 값을 구하는 것은 꽤 비싸다. 그러나 알고리즘 [Int64Util.approx_maximum_proper_udivisor](/lib/common/int64Util.ml#L143) 을 이용해 어느 정도의 결과를 얻을 수 있다. 알고리즘은 아래와 같다.

2부터 (임의로 적당히 정한)last_prime 까지의 솟수를 준비해두고 작은 솟수부터 나눗셈을 시도한다. 나누어떨어지는 솟수를 발견했다면, 이것이 가장 작은 진약수로 나눈 값을 얻은 것이므로 우리는 가장 큰 진약수를 정확하게 구한 것이다. 만약 정해둔 범위의 솟수들을 모두 시도했지만 나눗셈에 성공하지 못했다면 마지막 가장 큰 솟수로 그냥 나눈 값을 결과로 반환한다. 이 값을 X' 이라고 하자.

이때 X' <= post 를 만족한다면, 다음의 3가지 경우로 나누어 생각할 수 있다.
  - d1 - post 가 솟수라면:
    + X' = (d1 - post) / last_prime 이지만 이와 무관하게 무조건 d2 = d1 - post 이다.
  - 가장 큰 진약수 X가 존재하지만 알고리즘이 거기까지 도달하지 못했다면:
    + X' = (d1 - post) / last_prime, X <= X' 이다. 그런데 X' <= post 이면 X <= post 이므로 d2 = d1 - post 이다.
  - 가장 큰 진약수 X가 존재하며 그것을 정확히 찾은 것이면: X' = X 이고 X <= post 이므로 d2 = d1 - post 이다.

이와 같이 모든 경우에 대해, approx_maximum_proper_udivisor(d1 - post) <= post 이면 d2 = d1 - post 이다.
이렇게 특정한 조건을 만족할 때 d2의 값을 확정할 수 있다. 이 결과는 주로 post 의 값 벡터에 매우 큰 값이 포함되어있을 때 유용하게 활용된다.


이제 위의 정확한 값을 알 수 있을때 정보를 끄집어내는 데 성공했다면 그 정보를 meet 한 후 아래의 과정을 추가로 수행한다.

a) 우선 d2의 비트 표현상 연속된 suffix zero를 파악하면, post에서 그 zero 자리의 값이 d1과 같다는 사실을 알 수 있다.
예를 들어 b2 = 10111000으로 나눈 나머지 post의 비트 표현이 abcde 인 상황을 생각하면, b1 의 마지막 3비트는 cde 와 같을 것이다.
이것은 10진수에서 임의의 1000의 배수로 나눈 나머지에서 마지막 3자리가 그대로 보존되는 것과 같은 원리이다.

b) a)를 적용한 다음, d1과 post를 비교한다. 만약 이 둘이 절대 같은 값이 될 수 없다면 d1 > d2 임을 알 수 있다. 이유는 d2가 d1보다 클 때는 d1가 post로 그대로 전달되므로 둘이 같은 값이 될수밖에 없기 때문이다. 둘이 절대 같은 값이 될 수 없는지는 둘의 요약값을 meet 한 후 bot인지 체크하여 확인할 수 있다.
또한 post < d2 이므로 d2의 범위는 [post의 최솟값, d1의 최댓값] 으로 제약할 수 있다. post 최솟값이 d1 최댓값보다 커서 역전이 일어난다면 d2는 bot이다.
둘이 같은 값이 될 수도 있다면 post < d2 정보만 활용할 수 있으므로 d2의 범위는 [post의 최솟값, 도메인에서 사용 가능한 최댓값]이다.

c) 위에서 언급한 `post의 msb가 1이면, 즉 signed_min_int보다 크거나 같다면: d1 과 post가 반드시 같아야한다.` 조건을 활용하여, post 구간값의 lower bound가 signed_min_int 보다 크거나 같으면 항상 d1 = post 임을 알 수 있으므로 d1 값은 post와 meet 할 수 있다.

### (backward) bvsrem

```
bvsrem d1 d2 = post
```

forward bvsrem 에서와 마찬가지로 부호 조합을 생각해야한다. d1과 post의 부호는 반드시 같고, d2의 값은 항상 절댓값으로 사용된다.

bvsrem 연산 정의를 그대로 활용해 아래와 같이 처리한다.

d1을 음수 neg_d1과 양수 pos_d1 으로 쪼갠다.
post를 음수 neg_post와 양수 pos_post 로 쪼갠다.
d2를 음수 neg_d2과 양수 pos_d2로 쪼갠 후 neg_d2에 forward_neg를 적용하고 pos_d2와 join 하여 절댓값 abs_d2을 취한다.

이후 미리 정의된 bvurem 의 backward 분석을 활용해 다음 두 세트에 대해 backward 분석을 수행한다.
```
bvurem pos_d1 abs_d2 = pos_post
=> pos_d1', pos_d2'

bvuerm (forward_neg neg_d1) abs_d2 = (forward_neg neg_post)
=> neg_d1', neg_d2'
```

이때 양수 파트의 pos_d1'은 결과를 그대로 사용하면 되고, 음수 파트의 neg_d1' 결과는 절댓값을 이용해 계산된 결과이므로 forward_neg 하여 다시 음수로 뒤집어야한다. 그 둘을 join 한다.

각 d2' 은 원래 양수, 음수 어느 값이었건 절댓값을 이용해 계산한 것이므로 이 자리에는 이 값의 양수 버전이건 음수 버전이건 모두 올 수 있다.
예를 들어 |d2|의 값이 역방향 분석 결과 10일 것으로 계산되었다면 사실 d2의 값은 10과 -10 중 아무거나 와도 상관이 없기 때문에 -10과 10의 요약값을 join 해야한다.
따라서 pos_d2' 와 neg_d2', 그리고 각각을 forward_neg 한 것까지 모두 join 해야한다.

